<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用kermit通过串口升级openwrt uboot</title>
      <link href="/article/57e8f993/"/>
      <url>/article/57e8f993/</url>
      
        <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>因为购买的MT7688模块自带uboot，tftp升级固件功能无法使用，tftp一直显示错误，无法升级文件系统；</p><p>好在还可以通过串口升级uboot.</p><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200311155042.png" alt></p><p>在板子启动的时候，输入“7”来选择通过串口升级uboot，然后看到下面的输出：<br>Ready for binary (kermit) download to 0x80100000 at 57600 bps…</p><h1 id="ckermit串口工具"><a href="#ckermit串口工具" class="headerlink" title="ckermit串口工具"></a>ckermit串口工具</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Linux环境下使用较多的两款串口软件分别是minicom和ckermit，其中minicom用得最多，不少Linux发行版已经自带。但不少人反映minicom有时会有问题，u-boot开发者也都推荐使用ckermit，下面我们就来认识一下ckermit串口工具。<br>c-kermit是基于kermit文件传输协议的串口工具，其配置和使用较为简单；</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-shell"><code class="language-shell">sudo apt-get install ckermit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>c-kermit启动时，会从当前用户目录下查找.kermrc配置文件，因此我们先在$HOME目录下创建一个.kermrc文件，然后编辑文件内容如下：</p><pre><code>set line /dev/ttyUSB0　　 # 根据实际情况填写，可以用ls查看 /dev/tty*set speed 57600　　　　    # 根据实际情况填写set carrier-watch off set handshake none set flow-control none robust set file type bin set file name lit set rec  pack 1000 set send pack 1000　　    # 这里可以改大一点，方便下载内核set window 5 </code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><pre class="line-numbers language-shell"><code class="language-shell">#直接进入连接模式sudo kermit -c  #退回到命令模式，使用快捷键ctrl + \#如果需要再次x显示连接模式，直接输入c#在命令模式下可以输入shell命令来进行相应的操作,如cd 、ls、pwd等# 传输文件send filename#退出ckermitexit# 保存log,log将会保存在当前目录log session<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="uboot升级"><a href="#uboot升级" class="headerlink" title="uboot升级"></a>uboot升级</h1><pre class="line-numbers language-shell"><code class="language-shell">#与开发板的串口建立连接sudo kermit -c#开发板上电,输入7，进入使用kermit协议升级uboot模式#按快捷键 ctrl + \返回命令模式#发送uboot固件(可以在固件目录下完成以上操作，这样不需要带路径)send uboot.bin#固件传送完毕，uboot升级成功，开发板将自动重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/pyhou/p/7196622.html" target="_blank" rel="noopener">https://www.cnblogs.com/pyhou/p/7196622.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固件加头部信息</title>
      <link href="/article/b3de8d7/"/>
      <url>/article/b3de8d7/</url>
      
        <content type="html"><![CDATA[<h1 id="参考格式"><a href="#参考格式" class="headerlink" title="参考格式"></a>参考格式</h1><p>固件的头部信息，可以是多种格式，一般可能更多的是二进制数据格式，考虑到后期方便扩展，这里选择使用json格式。</p><pre><code>ABCD{    &quot;magic&quot;:&quot;device_xx&quot;,    &quot;appVer&quot;:&quot;1.0.1&quot;,    &quot;hardVer&quot;:&quot;1.0.1&quot;,    &quot;format&quot;:&quot;elf&quot;,    &quot;size&quot;:1234,    &quot;md5&quot;:&quot;2d02e669731cbade6a64b58d602cf2a4&quot;}</code></pre><h1 id="JSON参数说明"><a href="#JSON参数说明" class="headerlink" title="JSON参数说明"></a>JSON参数说明</h1><p><strong>ABCD</strong> – json数据的长度，2字节，16进制字串格式，如 3456表示0x3456;</p><p><strong>magic</strong> – 魔数，表示固件的类型，以<code>设备类型_XX</code>表示，其中<code>XX</code>用于区别同一类型设备的不同版本；</p><p><strong>appVer</strong> – 固件版本号，设备根据版本号决定是否升级；</p><p><strong>hardVer</strong> – 支持的硬件(最低)版本，设备根据硬件版本信息，判断此固件是否适用，从而决定是否可以升级；</p><p><strong>format</strong> – 固件格式，主要有如下格式：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>elf</td><td>linux可执行文件格式，主要用于网关</td></tr><tr><td>ipk</td><td>openwrt固件安装包格式，用于网关</td></tr><tr><td>bin</td><td>二进制格式, 主要用于子设备</td></tr><tr><td>hex</td><td>hex文件格式，主要用于子设备</td></tr></tbody></table><p><strong>size</strong> – 固件大小(不包含固件头json信息)，int型，占4字节，单位byte；</p><p><strong>md5</strong> – 固件的MD5校验值, 32位字符串。</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="jq-–-JSON命令行处理工具"><a href="#jq-–-JSON命令行处理工具" class="headerlink" title="jq – JSON命令行处理工具"></a>jq – JSON命令行处理工具</h2><h3 id="jq简介"><a href="#jq简介" class="headerlink" title="jq简介"></a>jq简介</h3><p>jq 是一款命令行下处理 JSON 数据的工具。其可以接受标准输入，命令管道或者文件中的 JSON 数据，经过一系列的过滤器(filters)和表达式的转后形成我们需要的数据结构并将结果输出到标准输出中。jq 的这种特性使我们可以很容易地在 Shell 脚本中调用它。</p><p>需要说明的是 jq 只能接受 well form 的 JSON 字符串作为输入内容。也就是说输入内容必须严格遵循 JSON 格式的标准。所有的属性名必须是以双引号包括的字符串。对象的最后一个属性的末尾或者数组的最后一个元素的末尾不能有逗号。否则 jq 会抛出无法解析 JSON 的错误。</p><h3 id="jq基本操作"><a href="#jq基本操作" class="headerlink" title="jq基本操作"></a>jq基本操作</h3><ul><li><p>帮助</p><pre class="line-numbers language-shell"><code class="language-shell">jq -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200309090742.png" alt></p></li><li><p>格式化json</p><pre class="line-numbers language-shell"><code class="language-shell"># -c 删除漂亮的格式输出echo '{"url": "mozillazg.com"}' |jq -c .{"url":"mozillazg.com"}echo '{"url": "mozillazg.com"}' |jq .{  "url": "mozillazg.com"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取某个key值<br><code>.key</code>, <code>.foo.bar</code>, <code>[&quot;key&quot;]</code></p><pre class="line-numbers language-shell"><code class="language-shell"># 如果key对应的值存在，则输出值echo '{"url": "mozillazg.com"}' |jq .url"mozillazg.com"echo '{"url": "mozillazg.com"}' | jq '.["url"]'"mozillazg.com"# 如果key对应的值不存在，则输出nullecho '{"notfoo": true, "alsonotfoo": false}' | jq '.foo'nullecho '{"notfoo": true, "alsonotfoo": false}' | jq .foonull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数组操作<br><code>.[]</code></p><pre class="line-numbers language-shell"><code class="language-shell"># 取出所有元素echo '[{"name": "tom"}, {"name": "mozillazg"}]' |jq .[]{  "name": "tom"}{  "name": "mozillazg"}# 取出第1个元素，下标从0开始echo '[{"name": "tom"}, {"name": "mozillazg"}]' |jq .[0]{  "name": "tom"}#取出下标为 0 到 2(不包括2)之间的元素echo '[{"name": "tom"}, {"name": "mozillazg"}, {"name": "jim"}]' |jq .[0:2][  {    "name": "tom"  },  {    "name": "mozillazg"  }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>取出数组元素中的key的值</p><pre class="line-numbers language-shell"><code class="language-shell">echo '[{"name": "foo"},{"name": "bar"},{"name": "foobar"}]' |jq .[].name"foo""bar""foobar"# 使用管道echo '[{"name": "foo"},{"name": "bar"},{"name": "foobar"}]' |jq '.[]|.name'"foo""bar""foobar"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将结果重新组成数组</p><pre class="line-numbers language-shell"><code class="language-shell">echo '[{"name": "foo"},{"name": "bar"},{"name": "foobar"}]' |jq [.[].name][  "foo",  "bar",  "foobar"]# 使用map实现echo '[{"name": "foo"},{"name": "bar"},{"name": "foobar"}]' |jq 'map(.name)'[  "foo",  "bar",  "foobar"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>处理文件</p><p>使用<code>jq [选项] &lt;jq表达式&gt; [files]</code>形式；<br>使用<code>cat [files] | jq [选项] &lt;jq表达式&gt;</code></p></li></ul><h3 id="jq高级操作"><a href="#jq高级操作" class="headerlink" title="jq高级操作"></a>jq高级操作</h3><ul><li><p>管道</p><ul><li>支持管道线|，它如同linux命令中的管道线——把前面命令的输出当作是后面命令的输入。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">echo '{"url": "mozillazg.com", "name": "mozillazg"}' | jq '.|.url'"mozillazg.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>获取内容的长度(字符串，数组的长度)</li></ul><pre class="line-numbers language-shell"><code class="language-shell">echo '{"url": "mozillazg.com", "name": "mozillazg"}' |jq '.url|length'13echo '["mozillazg.com", "mozillazg"]' |jq '.|length'2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>map<br><code>map(foo)</code>可以实现对数组的每一项进行操作，然后合并结果的功能:</p><pre class="line-numbers language-shell"><code class="language-shell">echo '["mozillazg.com", "mozillazg"]' | jq 'map(length)'[  13,  9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>filter(select)<br><code>select(foo)</code> 可以实现对输入项进行判断，只返回符合条件的项:</p><pre class="line-numbers language-shell"><code class="language-shell">echo '["mozillazg.com", "mozillazg"]' | jq 'map(select(.|length > 9))'[  "mozillazg.com"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串插值，拼接<br>可以使用 <code>\(foo)</code> 实现字符串插值功能:</p><pre class="line-numbers language-shell"><code class="language-shell">echo '{"url": "mozillazg.com", "name": "mozillazg"}' |jq '"hi \(.name)"'"hi mozillazg"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意要用双引号包围起来，表示是一个字符串。</p></li><li><p>if/elif/else<br>可以使用 <code>if .. then .. elif .. then .. else .. end</code> 实现条件判断:</p><pre class="line-numbers language-shell"><code class="language-shell">echo '[0, 1, 2, 3]' | jq 'map(if . == 0 then "zero" elif . == 1 then "one" elif . == 2 then "two" else "many" end)'[  "zero",  "one",  "two",  "many"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造object或数组<br>可以通过 <code>{}</code> 和 <code>[]</code> 构造新的 object 或 数组：</p><pre class="line-numbers language-shell"><code class="language-shell"># objectecho '["mozillazg.com", "mozillazg"]' |jq '{name: .[1]}'{  "name": "mozillazg"}# arrayecho '{"url": "mozillazg.com", "name": "mozillazg"}' |jq '[.name, .url]'[  "mozillazg",  "mozillazg.com"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="jq内置运算支持"><a href="#jq内置运算支持" class="headerlink" title="jq内置运算支持"></a>jq内置运算支持</h3><p>jq 内部支持的数据类型有：数字，字符串，数组和对象(object)。并且在这些数据类型的基础上, jq 提供了一些基本的操作符来实现一些基本的运算和数据操作。列举如下：</p><ul><li>数学运算。对于数字类型，jq 实现了基本的加减乘除(/)和求余(%)运算。对于除法运算，jq 最多支持 16 位小数。</li><li>字符串操作。jq 提供字符串的连接操作(运算符为’+’，例如：”tom “+”jerry”结果为”tom jerry”)，字符串的复制操作(例如：’a’*3 结果为’aaa’)，以及字符串分割操作(将字符串按照指定的分割符分成数组，例如”sas”/“s”的结果为[“”,”a”,””]，而”sas”/“a”的结果为[“s”,”s”]。</li><li>数组操作。jq 提供两种数组运算：并集(‘+’)运算，结果数组中包含参与运算的数组的所有元素。差集运算(‘-‘)，例如：有数组 a,b, a-b 的结果为所有在 a 中且不包含在 b 中的元素组成的数组。</li><li>对象操作。jq 实现了两个 JSON 对象的合并操作(merge)。当两个参与运算的对象包含相同的属性时则保留运算符右侧对象的属性值。有两种合并运算符：’+’和’<em>‘。所不同的是，运算符’+’只做顶层属性的合并，运算符’</em>‘则是递归合并。例如：有对象 a={“a”:{“b”:1}}, b={“a”:{“c”:2}}，a+b 的结果为{“a”:{“c”:2}}，而 a*b 的结果为{“a”:{“b”:1,”c”:2}}</li><li>比较操作：jq 内部支持的比较操作符有==, !=,&gt;,&gt;=,&lt;=和&lt;。其中，’==’的规则和 javascript 中的恒等(‘===’)类似，只有两个操作数的类型和值均相同时其结果才是 true。</li><li>逻辑运算符: and/or/not。在 jq 逻辑运算中，除了 false 和 null 外，其余的任何值都等同于 true。</li><li>默认操作符(‘//‘), 表达式’a//b’表示当表达式 a 的值不是 false 或 null 时，a//b 等于 a，否则等于 b。</li></ul><h3 id="jq修改json数据"><a href="#jq修改json数据" class="headerlink" title="jq修改json数据"></a>jq修改json数据</h3><p>原json内容：<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200309142452.png" alt></p><p>例如需要修改size的值为123，方式如下：</p><pre class="line-numbers language-shell"><code class="language-shell">#重定向到新的文件，注意不能是原文件cat firmware.json | jq 'to_entries |map(if .key == "size"then . + {"value":123}else .end) |from_entries' > new.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200309143222.png" alt></p><h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/1612_chengg_jq/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1612_chengg_jq/index.html</a></p><p><a href="https://mozillazg.com/2018/01/jq-use-examples-cookbook.html#hidid4" target="_blank" rel="noopener">https://mozillazg.com/2018/01/jq-use-examples-cookbook.html#hidid4</a></p><p><a href="https://github.com/meetbill/xbatch/wiki/jq#22-%E6%A0%B9%E6%8D%AE-key-%E6%9F%A5%E8%AF%A2-json-%E7%9A%84%E5%80%BC" target="_blank" rel="noopener">https://github.com/meetbill/xbatch/wiki/jq#22-%E6%A0%B9%E6%8D%AE-key-%E6%9F%A5%E8%AF%A2-json-%E7%9A%84%E5%80%BC</a></p><p><a href="https://www.jianshu.com/p/f50c87b7eaea" target="_blank" rel="noopener">https://www.jianshu.com/p/f50c87b7eaea</a></p></blockquote><h2 id="shell获取文件的大小"><a href="#shell获取文件的大小" class="headerlink" title="shell获取文件的大小"></a>shell获取文件的大小</h2><pre class="line-numbers language-shell"><code class="language-shell">ls -l filename | awk '{print $5}'du -b filename | awk '{print $1}'wc -c filename | awk '{print $1}'wc -c < filenamestat -c "%s" filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shell计算文件的MD5"><a href="#shell计算文件的MD5" class="headerlink" title="shell计算文件的MD5"></a>shell计算文件的MD5</h2><p><strong>md5sum</strong>: </p><p>显示或检查 MD5(32-bit) 校验和，若没有文件选项，或者文件处为”-“，则从标准输入读取。<br><strong>echo -n</strong> : 不打印换行符。<br><strong>cut</strong>: cut用来从标准输入或文本文件中剪切列或域。剪切文本可以将之粘贴到一个文本文件。<br>        -d 指定与空格和tab键不同的域分隔符。-f1 表示第一个域。</p><pre class="line-numbers language-shell"><code class="language-shell">md5sum iot_gateway5b5e4be07a7960ef1450f3e8c8b22df9  iot_gatewaymd5sum iot_gateway | cut -d ' ' -f15b5e4be07a7960ef1450f3e8c8b22df9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shell删除某个字符"><a href="#shell删除某个字符" class="headerlink" title="shell删除某个字符"></a>shell删除某个字符</h2><p>例如使用 <code>tr -d &#39;[ \t]</code> 删除换行字符</p><pre class="line-numbers language-shell"><code class="language-shell">echo "    123  567   " | tr -d '[ \t]' #输出12345<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="使用shell添加头部信息"><a href="#使用shell添加头部信息" class="headerlink" title="使用shell添加头部信息"></a>使用shell添加头部信息</h1><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash# 删除旧固件rm -rf ./iot_gateway*.elfrm -rf ./iot_gateway*.ipk# 生成的固件路径FIRMWARE_ELF_DIR= xxxFIRMWARE_IPK_DIR= xxx# 固件加头打包时间PACK_TIME=$(date "+%Y-%m-%d %H:%M:%S")echo "packtime: $PACK_TIME"# 拷贝固件至当前目录暂存cp $FIRMWARE_ELF_DIR/iot_gateway ./raw.elfcp $FIRMWARE_IPK_DIR/iot_gateway*.ipk ./raw.ipkecho "copy firmware done."# 获取固件的大小ELF_SIZE=$(ls -l ./raw.elf | awk '{print $5}')IPK_SIZE=$(ls -l ./raw.ipk | awk '{print $5}')echo "elf size: $ELF_SIZE"echo "ipk size: $IPK_SIZE"# 计算固件的MD5ELF_MD5=$(md5sum raw.elf | cut -d ' ' -f1)IPK_MD5=$(md5sum raw.ipk | cut -d ' ' -f1)echo "elf md5: $ELF_MD5"echo "ipk md5: $ELF_MD5"# 填充固件头信息到jsoncat firmware.json |    jq -c "to_entries |        map(if .key == \"size\"            then . + {\"value\":$ELF_SIZE}            elif .key == \"format\"            then . + {\"value\":\"elf\"}            elif .key == \"timestamp\"            then . + {\"value\":\"$PACK_TIME\"}            elif .key == \"md5\"            then . + {\"value\":\"$ELF_MD5\"}            else .            end           ) |        from_entries" | tr -d '\n' > elf.jsoncat firmware.json |    jq -c "to_entries |        map(if .key == \"size\"            then . + {\"value\":$IPK_SIZE}            elif .key == \"format\"            then . + {\"value\":\"ipk\"}            elif .key == \"timestamp\"            then . + {\"value\":\"$PACK_TIME\"}            elif .key == \"md5\"            then . + {\"value\":\"$IPK_MD5\"}            else .            end           ) |        from_entries" | tr -d '\n' > ipk.json#Debug: printf json信息echo "elf.json:"cat ./elf.json | jq .echo "ipk.json:"cat ./ipk.json | jq .# 获取软件版本ELF_APP_VER=$(cat ./elf.json | jq --raw-output '.appVer')        IPK_APP_VER=$(cat ./ipk.json | jq --raw-output '.appVer')echo "elf app version: $ELF_APP_VER"echo "ipk app version: $IPK_APP_VER"# 计算json的长度,16进制字符串格式ELF_JSON_LEN=$(ls -l ./elf.json | awk '{printf "%04x\n",$5}')IPK_JSON_LEN=$(ls -l ./ipk.json | awk '{printf "%04x\n",$5}')echo "elf json len: $ELF_JSON_LEN"echo "ipk json len: $IPK_JSON_LEN"# 保存到文件echo -n "$ELF_JSON_LEN" >elf.lenecho -n "$IPK_JSON_LEN" >ipk.len# 合并文件cat elf.len elf.json raw.elf >iot_gateway_$ELF_APP_VER.elfcat ipk.len ipk.json raw.ipk >iot_gateway_$ELF_APP_VER.ipkecho "Generate Pakage Done."# 删除生成的临时文件rm -rf elf.json ipk.json raw.elf raw.ipk elf.len ipk.len        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt软件包创建</title>
      <link href="/article/a2e5f92e/"/>
      <url>/article/a2e5f92e/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200217214719.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200217214930.png" alt></p><blockquote><p><a href="https://lingxiankong.github.io/2014-01-06-linux-install.html" target="_blank" rel="noopener">https://lingxiankong.github.io/2014-01-06-linux-install.html</a></p></blockquote><h1 id="Openwrt软件源码包的结构"><a href="#Openwrt软件源码包的结构" class="headerlink" title="Openwrt软件源码包的结构"></a>Openwrt软件源码包的结构</h1><ul><li>Makefile(必选)<ul><li>提供了下载、编译、安装的步骤</li></ul></li><li>patches(可选)<ul><li>补丁文件，用于对源码打补丁</li></ul></li><li>files(可选)<ul><li>配置文件目录</li></ul></li></ul><h1 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h1><h2 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h2><p>OpenWrt使用三个Makefile的子文件，分别为：</p><blockquote><p><strong>include $(TOPDIR)/rules.mk</strong></p><p><strong>include $(INCLUDE_DIR)/kernel.mk</strong></p><p><strong>include $(INCLUDE_DIR)/package.mk</strong></p></blockquote><p>由这些Makefile子文件确定软件包加入OpenWrt的方式和方法。$(TOPDIR)/rules.mk一般在Makefile的开头，$(INCLUDE_DIR)/kernel.mk文件对于软件包为内核时是不可缺少的，$(INCLUDE_DIR)/package.mk一般在软件包的基本信息完成后再引入。</p><h2 id="示例Makefile"><a href="#示例Makefile" class="headerlink" title="示例Makefile"></a>示例Makefile</h2><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>TOPDIR<span class="token punctuation">)</span>/rules.mkPKG_NAME<span class="token operator">:=</span>bridgePKG_VERSION<span class="token operator">:=</span>1.0.6PKG_RELEASE<span class="token operator">:=</span>1PKG_BUILD_DIR<span class="token operator">:=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/bridge-utils-<span class="token variable">$</span><span class="token punctuation">(</span>PKG_VERSION<span class="token punctuation">)</span>PKG_SOURCE<span class="token operator">:=</span>bridge-utils-<span class="token variable">$</span><span class="token punctuation">(</span>PKG_VERSION<span class="token punctuation">)</span>.tar.gzPKG_SOURCE_URL<span class="token operator">:=</span><span class="token operator">@</span>SF/bridgePKG_MD5SUM<span class="token operator">:=</span>9b7dc52656f5cbec846a7ba3299f73bdPKG_CAT<span class="token operator">:=</span>zcat<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUDE_DIR<span class="token punctuation">)</span>/package.mk<span class="token keyword">define</span> Package/bridge  SECTION<span class="token operator">:=</span>base  CATEGORY<span class="token operator">:=</span>Network  TITLE<span class="token operator">:=</span>Ethernet bridging configuration utility  <span class="token comment" spellcheck="true">#DESCRIPTION:=This variable is obsolete. use the Package/name/description define instead!</span>  URL<span class="token operator">:=</span>http<span class="token punctuation">:</span>//bridge.sourceforge.net/<span class="token keyword">endef</span><span class="token keyword">define</span> Package/bridge/description Ethernet bridging configuration utility Manage ethernet bridging<span class="token punctuation">;</span> a way to connect networks together to form a larger network.<span class="token keyword">endef</span><span class="token keyword">define</span> Build/Configure  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> Build/Configure/Default,--with-linux-headers<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>LINUX_DIR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">endef</span><span class="token keyword">define</span> Package/bridge/install  <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/sbin  <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/brctl/brctl <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/sbin/<span class="token keyword">endef</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">eval</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> BuildPackage,bridge<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最为关键的<strong>BuildPackage</strong>宏。它是在<strong>$(INCLUDE_DIR)/package.mk</strong>文件里定义的。<strong>BuildPackage宏只要求一个参数，即要编译的软件包名</strong>，在本例中是“bridge”。所有其他信息都通过宏来获得，这提供了一种内在的简洁性。比如BuildPackage需要软件包的一大串描述信息，我们并不要向它传递冗长的参数，因为我们已经约定描述信息定义在DESCRIPTION宏，BuildPackage从里面读取就可以了。</p><h2 id="软件包信息"><a href="#软件包信息" class="headerlink" title="软件包信息"></a>软件包信息</h2><p>软件包的信息均以PKG_开头，其意思和作用如下：</p><ul><li><strong>PKG_NAME</strong> -软件包的名字, 在 menuconfig 和 ipkg 显示</li><li><strong>PKG_VERSION</strong> -软件包的版本，主干分支的版本正是我们要下载的</li><li><strong>PKG_RELEASE</strong> -这个 makefile 的版本</li><li><strong>PKG_BUILD_DIR</strong> -编译软件包的目录</li><li><strong>PKG_SOURCE</strong> -要下载的软件包的名字，一般是由 PKG_NAME 和 PKG_VERSION 组成</li><li><strong>PKG_SOURCE_URL</strong> -下载这个软件包的链接</li><li><strong>PKG_MD5SUM</strong> -软件包的 MD5 值</li><li><strong>PKG_CAT</strong> -解压软件包的方法 (zcat, bzcat, unzip)</li><li><strong>PKG_BUILD_DEPENDS</strong> -<strong>需要预先构建的软件包，但只是在构建本软件包时，而不是运行的时候</strong>。它的语法和下面的DEPENDS一样。</li></ul><p>PKG_*变量定义了从何处下载这个软件包；@SF是表示从sourceforge网站下载的一个特殊关键字。md5sum用来检查从网上下载的软件包是否完好无损。PKG_BUILD_DIR定义了软件包源代码的解压路径。</p><h2 id="BuildPackage相关的宏"><a href="#BuildPackage相关的宏" class="headerlink" title="BuildPackage相关的宏"></a>BuildPackage相关的宏</h2><p>应用程序的编译包以Package/开头。然后接着软件名，在Package定义中的软件名可以与软件包名不一样，而且可以多个定义。下面使用$(PKG_NAME)只是做一个标志，并非真正使用$(PKG_NAME)，如Package/$(PKG_NAME)。</p><ul><li><strong>SECTION</strong> 表示包的类型，预留。</li><li><strong>CATRGORY</strong> 表示分类，在make menuconfig的菜单下将可以找到。</li><li><strong>TITLE</strong> 用于软件包的简短描述。</li><li><strong>DESCRIPTION</strong> 用于软件包的详细描述，<strong>已放弃使用</strong>。如果使用DESCRIPTION将会提示“error DESCRIPTION:= is obsolete, use Package/PKG_NAME/description”。</li><li><strong>URL</strong> 表示软件包的下载位置。</li><li><strong>MAINTAIER</strong> 表示维护者，选项。</li><li><strong>DEPENDS</strong> 表示与其他软件的依赖。<strong>运行本软件依赖的其他包</strong>。如果存在多个依赖，则每个依赖需要用空格分开。依赖前使用+号表示默认为显示，即对象没有选中时也会显示，使用@则默认为不显示，即当依赖对象选中后才显示。</li></ul><blockquote><p>在用户空间的应用程序软件包中没有内核驱动模块的AUTOLOAD参数。<strong>如果应用软件需要在boot时自动运行，则需要在/etc/init.d中增加相应的脚本文件。脚本文件需要START参数，说明在boot时的优先级，如果在boot过程启动后再关闭，则需要进一步设置STOP参数。如果STOP参数存在，其值必须大于START。脚本文件需要start()和stop()两个函数，start()是执行程序，stop()是关闭程序。</strong>关闭程序一般需要执行killall命令。<strong>由/etc/rc.d/S10boot知道，装载内核驱动模块的优先级为10，需要使用自己设计的内核驱动模块的程序其START的值必须大于10。同样由/etc/rc.d/S40network知道，使用网络通信的程序其START的值必须大于40</strong>。</p></blockquote><ul><li><strong>Package/$(PKG_NAME)/conffiles</strong> 本包安装的配置文件，一行一个。如果文件结尾使用/，则表示为目录。用于备份配置文件说明，在sysupgrade命令执行时将会用到。</li><li><strong>Package/$(PKG_NAME)/description</strong> 软件包的详细描述，取代前面提到的DESCRIPTION详细描述。</li><li><strong>Build/Prepare</strong> 编译准备方法，对于网上下载的软件包不需要再描述。对于非网上下载或自行开发的软件包必须说明编译准备方法。一般的准备方法为：</li></ul><pre class="line-numbers language-ruby"><code class="language-ruby">define <span class="token constant">Build</span><span class="token operator">/</span><span class="token constant">Prepare</span>    mkdir <span class="token operator">-</span>p $<span class="token punctuation">(</span><span class="token constant">PKG_BUILD_DIR</span><span class="token punctuation">)</span>    $<span class="token punctuation">(</span><span class="token constant">CP</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token regex">/* $(PKG_BUILD_DIR)/</span>endef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>按OpenWrt的习惯，一般把自己设计的程序全部在src目录下。</p><ul><li><strong>Build/Compile</strong> 编译方法，没有特别说明的可以不予以定义。如果不定义将默认使用编译方法Build/Compile/Default。<br> 自行开发的软件包可以考虑使用下面的定义。</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Build/Compile    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span> \    <span class="token variable">$</span><span class="token punctuation">(</span>TARGET_CONFIGURE_OPTS<span class="token punctuation">)</span> CFLAGS<span class="token operator">=</span><span class="token string">"$(TARGET_CFLAGS) -I $(LINUX_DIR)/include"</span><span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Package/$(PKG_NAME)/install</strong> 软件包的安装方法，包括一系列拷贝编译好的文件到指定位置。<strong>调用时会带一个参数，就是嵌入式系统的镜像文件系统目录</strong>，因此<strong>$(1)表示嵌入式系统的镜像目录</strong>。一般可以采用下面的方法：</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Package/<span class="token variable">$</span><span class="token punctuation">(</span>PKG_NAME<span class="token punctuation">)</span>/install    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/bin    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>PKG_NAME<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/bin/<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>INSTALL_DIR、INSTALL_BIN在$(TOPDIR)/rules.mk文件定义，所以本Makefile必须引入$(TOPDIR)/rules.mk文件。<br> <strong>INSTALL_DIR:=install -d -m0755</strong> 意思是创建所属用户可读写和执行，其他用户可读可执行的目录。<br> <strong>INSTALL_BIN:=install -m0755</strong> 意思是编译好的文件存放到镜像文件目录。<br> 如果用户空间的应用软件在boot时要自动运行，则需要在安装方法说明中增加自动运行的脚本文件安装和配置文件安装方法。<br> 例如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Package/mountd/install    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/sbin/ <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/config/ <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/init.d/    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/mountd <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/sbin/    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DATA<span class="token punctuation">)</span> ./files/mountd.config <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/config/mountd    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> ./files/mountd.init <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/init.d/mountd<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装文件放在files子目录下，不要与源代码文件目录src混在一起，以提高可读性。使用清晰的文件扩展名，更方便安装识别文件。</p><ul><li><strong>Package/$(PKG_NAME)/preinst</strong> 软件包安装前处理方法，使用脚本语言，因此定义的第一行需要下面的格式<br> <code>#!/bin/sh</code><br> 调用时带入的参数为嵌入式系统的镜像目录。</li><li><strong>Package/$(PKG_NAME)/postinst</strong> 软件包安装后处理方法，使用脚本语言。</li><li><strong>Package/$(PKG_NAME)/prerm</strong> 软件包删除前处理方法，使用脚本语言。</li><li><strong>Package/$(PKG_NAME)/postrm</strong> 软件包删除后处理方法，使用脚本语言。</li></ul><p><strong>注意：</strong>对于所有在pre/post, install/removal脚本中使用的变量，<strong>都应该使用”$$“代替”$“</strong>。这是告诉make暂时不要解析这个变量，而是把它当成普通字符串以及用”$“代替”$$“</p><h2 id="内核驱动模块包定义"><a href="#内核驱动模块包定义" class="headerlink" title="内核驱动模块包定义"></a>内核驱动模块包定义</h2><p>Linux分为内核空间和用户空间。开发者开发的内核部分可以直接加入Linux的Kernel程序，也可以生成内核模块以便需要时装入内核。OpenWrt一般希望开发者生成内核模块，在Linux启动后自动装载或手工使用insmod命令装载。内核模块使用KernelPackage开头，其他与一般应用软件包基本相同。<br> 在内核驱动模块定义中增加了：</p><ul><li><strong>SUBMENU</strong> 表示子菜单位置，在$(INCLUDE)/kernel.mk对内核模块定义了CATEGORY为kernel modules，所以内核模块在menuconfig中的主菜单为kernel modules，然后有下一级子菜单$(SUBMENU)。在子菜单下可以看到以kmod-$(PKG_NAME)项目。</li><li><strong>DEFAULT</strong> 表示直接编入内核或产生内核模块，y表示直接编入内核，m表示产生内核模块。</li><li><strong>AUTOLOAD</strong> 表示自动装入内核，一般表示方法为：<br> <code>AUTOLOAD:=$(call AutoLoad, $(PRIORITY),$(AUTOLOAD_MODS))</code><br> AutoLoad的第一个参数$(PRIORITY)为优先级，01为最优先，99为最后装载。有关自动装载可以在/etc/modules.d目录下看到，第二个参数$(AUTOLOAD_MODS)模块名，每个模块名以空格符分隔。即可同时装载多个内核模块。<br> 在开发过程最好不要使用自动装载，经过严格调试后再使用，可以减轻调试的工作量。</li></ul><h2 id="使用定义"><a href="#使用定义" class="headerlink" title="使用定义"></a>使用定义</h2><p>完成前面定义后，必须使用eval函数实现各种定义。其格式为：<br> 对于一般应用软件包<br> <code>$(eval $(call Package, $(PKG_NAME)))</code><br> 或对于内核驱动模块<br> <code>$(eval $(call KernelPackage, $(PKG_NAME)))</code><br> 如果一个软件包有多个程序，例如：一个应用程序有自己的内核驱动模块，上面使用PKG_NAME需要灵活变通。eval函数可以设计多个。也可以当成多个软件包处理。</p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><blockquote><p><a href="https://www.jianshu.com/p/21c8937ac7ea" target="_blank" rel="noopener">https://www.jianshu.com/p/21c8937ac7ea</a></p><p><a href="https://openwrt.org/zh-cn/doc/devel/packages" target="_blank" rel="noopener">https://openwrt.org/zh-cn/doc/devel/packages</a></p></blockquote><h1 id="开机自启动配置"><a href="#开机自启动配置" class="headerlink" title="开机自启动配置"></a>开机自启动配置</h1><ul><li><p>创建文件夹</p><pre class="line-numbers language-shell"><code class="language-shell">mkdir -p package/helloworld/filescd package/helloworld/filestouch helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>编写脚本<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200218113811.png" alt></p></li><li><p>修改helloworld 目录下的Makefile<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200218113854.png" alt></p></li></ul><h1 id="重复安装保留配置文件"><a href="#重复安装保留配置文件" class="headerlink" title="重复安装保留配置文件"></a>重复安装保留配置文件</h1><ul><li><p>问题<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200218114051.png" alt></p></li><li><p>解决方法<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200218114157.png" alt></p></li><li><p>引用</p><blockquote><p><a href="https://stackoverflow.com/questions/34512804/how-to-keep-config-after-reinstall-ipk-on-openwrt" target="_blank" rel="noopener">https://stackoverflow.com/questions/34512804/how-to-keep-config-after-reinstall-ipk-on-openwrt</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typoro PicGo MarkDown协同工作</title>
      <link href="/article/32c0b2ae/"/>
      <url>/article/32c0b2ae/</url>
      
        <content type="html"><![CDATA[<h1 id="Tyora简介"><a href="#Tyora简介" class="headerlink" title="Tyora简介"></a>Tyora简介</h1><ul><li><p>官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p></li><li><p>Typora 是一款简单、高效而且非常优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。</p><p>Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。</p><p>Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一。</p></li><li><p>Tyora快捷键</p><ul><li>段落<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200213002205.png" alt></li><li>格式<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200213002455.png" alt></li></ul></li></ul><h1 id="Pandoc文档格式转化"><a href="#Pandoc文档格式转化" class="headerlink" title="Pandoc文档格式转化"></a>Pandoc文档格式转化</h1><ul><li><p>官网 <a href="https://pandoc.org/" target="_blank" rel="noopener">https://pandoc.org/</a></p></li><li><p>简介：</p></li><li><p><em>Pandoc*</em>是一个标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。<br>Typora 的文件导入/导出功能使用 Pandoc 把 Markdown 源码转换成不同的文件格式，所以我们如果想使用文件导入/导出功能，必须先安装 Pandoc。<br>如果不安装 Pandoc，Typora 只支持导出 HTML 和 PDF 格式的文件。<br>如果安装了 Pandoc ：<br>Typora 支持的导入文件格式: .docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub.<br>Typora 支持的导出文件格式 : HTML, PDF, Docx, odt, rtf, Epub, LaTeX, Media Wiki,Image.</p></li><li><p>安装方式：<br>STEP 1. 打开下载页面：<a href="https://github.com/jgm/pandoc/releases/latest" target="_blank" rel="noopener">https://github.com/jgm/pandoc/releases/latest</a><br>STEP 2. 下载最新的安装包：pandoc-版本号.msi<br>STEP 3. 双击后按照提示一步步安装</p></li></ul><h1 id="PicGo图床"><a href="#PicGo图床" class="headerlink" title="PicGo图床"></a>PicGo图床</h1><ul><li><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p></li><li><p>简介：<br>PicGo: 一个用于快速上传图片并获取图片URL链接的工具<br>PicGo 本体支持如下图床：</p><ul><li>微博图床 v1.0 微博图床从 2019 年 4 月开始进行防盗链，不建议继续使用</li><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS v1.5.1 由于官方不再支持V1版本，暂时请使用smms-user插件</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul></li><li><p>特色功能</p><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows和macOS支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：<code>command+shift+p</code>（macOS）| <code>control+shift+p</code>（Windows\Linux)</li><li>支持插件系统，已有插件支持Gitee、青云等第三方图床<ul><li>更多第三方插件以及使用了 PicGo 底层的应用可以在 <a href="https://github.com/PicGo/Awesome-PicGo" target="_blank" rel="noopener">Awesome-PicGo</a> 找到。欢迎贡献！</li></ul></li><li>支持通过发送HTTP请求调用 PicGo 上传（v2.2.0+)</li></ul></li></ul><h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><blockquote><p><a href="https://www.jianshu.com/p/45ff441ac0d6" target="_blank" rel="noopener">Typora：简单高效的 Markdown 编辑器</a><br><a href="https://www.jianshu.com/p/a0bf28d7f2fd" target="_blank" rel="noopener">Typora + PicGo MarkDown完美组合</a><br><a href="https://www.jianshu.com/p/44c8aaa9cda1" target="_blank" rel="noopener">Typora - 不要太棒的Markdown编辑器</a><br><a href="https://www.cnblogs.com/lc1203/p/ac5d44992d9c5f84bf3383d15aff40c2.html" target="_blank" rel="noopener">高效且优雅的笔记记录：为知笔记+Typora+图床</a><br><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Picgo github readme</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高效 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo cmd</title>
      <link href="/article/339e02f9/"/>
      <url>/article/339e02f9/</url>
      
        <content type="html"><![CDATA[<h1 id="新建网站"><a href="#新建网站" class="headerlink" title="新建网站"></a>新建网站</h1><pre><code>hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><pre><code>hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code>hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h1 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h1><pre><code>hexo g</code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h1 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h1><pre><code>hexo s</code></pre><p>默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>hexo d</code></pre><h1 id="清除生成的静态页面"><a href="#清除生成的静态页面" class="headerlink" title="清除生成的静态页面"></a>清除生成的静态页面</h1><pre><code>hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>引用地址：</p><p>从hexo.io说明文档拷贝</p><blockquote><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/article/d4a1185/"/>
      <url>/article/d4a1185/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这是一个测试。<br><img src="https://s2.ax1x.com/2020/02/10/15r7oF.png" alt="15r7oF.png"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world !\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
