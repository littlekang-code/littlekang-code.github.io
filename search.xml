<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Openwrt软件包创建</title>
      <link href="/article/a2e5f92e/"/>
      <url>/article/a2e5f92e/</url>
      
        <content type="html"><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200217214719.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200217214930.png" alt></p><blockquote><p><a href="https://lingxiankong.github.io/2014-01-06-linux-install.html" target="_blank" rel="noopener">https://lingxiankong.github.io/2014-01-06-linux-install.html</a></p></blockquote><h1 id="Openwrt软件源码包的结构"><a href="#Openwrt软件源码包的结构" class="headerlink" title="Openwrt软件源码包的结构"></a>Openwrt软件源码包的结构</h1><ul><li>Makefile(必选)<ul><li>提供了下载、编译、安装的步骤</li></ul></li><li>patches(可选)<ul><li>补丁文件，用于对源码打补丁</li></ul></li><li>files(可选)<ul><li>配置文件目录</li></ul></li></ul><h1 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h1><h2 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h2><p>OpenWrt使用三个Makefile的子文件，分别为：</p><blockquote><p><strong>include $(TOPDIR)/rules.mk</strong></p><p><strong>include $(INCLUDE_DIR)/kernel.mk</strong></p><p><strong>include $(INCLUDE_DIR)/package.mk</strong></p></blockquote><p>由这些Makefile子文件确定软件包加入OpenWrt的方式和方法。$(TOPDIR)/rules.mk一般在Makefile的开头，$(INCLUDE_DIR)/kernel.mk文件对于软件包为内核时是不可缺少的，$(INCLUDE_DIR)/package.mk一般在软件包的基本信息完成后再引入。</p><h2 id="示例Makefile"><a href="#示例Makefile" class="headerlink" title="示例Makefile"></a>示例Makefile</h2><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>TOPDIR<span class="token punctuation">)</span>/rules.mkPKG_NAME<span class="token operator">:=</span>bridgePKG_VERSION<span class="token operator">:=</span>1.0.6PKG_RELEASE<span class="token operator">:=</span>1PKG_BUILD_DIR<span class="token operator">:=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/bridge-utils-<span class="token variable">$</span><span class="token punctuation">(</span>PKG_VERSION<span class="token punctuation">)</span>PKG_SOURCE<span class="token operator">:=</span>bridge-utils-<span class="token variable">$</span><span class="token punctuation">(</span>PKG_VERSION<span class="token punctuation">)</span>.tar.gzPKG_SOURCE_URL<span class="token operator">:=</span><span class="token operator">@</span>SF/bridgePKG_MD5SUM<span class="token operator">:=</span>9b7dc52656f5cbec846a7ba3299f73bdPKG_CAT<span class="token operator">:=</span>zcat<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>INCLUDE_DIR<span class="token punctuation">)</span>/package.mk<span class="token keyword">define</span> Package/bridge  SECTION<span class="token operator">:=</span>base  CATEGORY<span class="token operator">:=</span>Network  TITLE<span class="token operator">:=</span>Ethernet bridging configuration utility  <span class="token comment" spellcheck="true">#DESCRIPTION:=This variable is obsolete. use the Package/name/description define instead!</span>  URL<span class="token operator">:=</span>http<span class="token punctuation">:</span>//bridge.sourceforge.net/<span class="token keyword">endef</span><span class="token keyword">define</span> Package/bridge/description Ethernet bridging configuration utility Manage ethernet bridging<span class="token punctuation">;</span> a way to connect networks together to form a larger network.<span class="token keyword">endef</span><span class="token keyword">define</span> Build/Configure  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> Build/Configure/Default,--with-linux-headers<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>LINUX_DIR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">endef</span><span class="token keyword">define</span> Package/bridge/install  <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/sbin  <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/brctl/brctl <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/sbin/<span class="token keyword">endef</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">eval</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> BuildPackage,bridge<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最为关键的<strong>BuildPackage</strong>宏。它是在<strong>$(INCLUDE_DIR)/package.mk</strong>文件里定义的。<strong>BuildPackage宏只要求一个参数，即要编译的软件包名</strong>，在本例中是“bridge”。所有其他信息都通过宏来获得，这提供了一种内在的简洁性。比如BuildPackage需要软件包的一大串描述信息，我们并不要向它传递冗长的参数，因为我们已经约定描述信息定义在DESCRIPTION宏，BuildPackage从里面读取就可以了。</p><h2 id="软件包信息"><a href="#软件包信息" class="headerlink" title="软件包信息"></a>软件包信息</h2><p>软件包的信息均以PKG_开头，其意思和作用如下：</p><ul><li><strong>PKG_NAME</strong> -软件包的名字, 在 menuconfig 和 ipkg 显示</li><li><strong>PKG_VERSION</strong> -软件包的版本，主干分支的版本正是我们要下载的</li><li><strong>PKG_RELEASE</strong> -这个 makefile 的版本</li><li><strong>PKG_BUILD_DIR</strong> -编译软件包的目录</li><li><strong>PKG_SOURCE</strong> -要下载的软件包的名字，一般是由 PKG_NAME 和 PKG_VERSION 组成</li><li><strong>PKG_SOURCE_URL</strong> -下载这个软件包的链接</li><li><strong>PKG_MD5SUM</strong> -软件包的 MD5 值</li><li><strong>PKG_CAT</strong> -解压软件包的方法 (zcat, bzcat, unzip)</li><li><strong>PKG_BUILD_DEPENDS</strong> -<strong>需要预先构建的软件包，但只是在构建本软件包时，而不是运行的时候</strong>。它的语法和下面的DEPENDS一样。</li></ul><p>PKG_*变量定义了从何处下载这个软件包；@SF是表示从sourceforge网站下载的一个特殊关键字。md5sum用来检查从网上下载的软件包是否完好无损。PKG_BUILD_DIR定义了软件包源代码的解压路径。</p><h2 id="BuildPackage相关的宏"><a href="#BuildPackage相关的宏" class="headerlink" title="BuildPackage相关的宏"></a>BuildPackage相关的宏</h2><p>应用程序的编译包以Package/开头。然后接着软件名，在Package定义中的软件名可以与软件包名不一样，而且可以多个定义。下面使用$(PKG_NAME)只是做一个标志，并非真正使用$(PKG_NAME)，如Package/$(PKG_NAME)。</p><ul><li><strong>SECTION</strong> 表示包的类型，预留。</li><li><strong>CATRGORY</strong> 表示分类，在make menuconfig的菜单下将可以找到。</li><li><strong>TITLE</strong> 用于软件包的简短描述。</li><li><strong>DESCRIPTION</strong> 用于软件包的详细描述，<strong>已放弃使用</strong>。如果使用DESCRIPTION将会提示“error DESCRIPTION:= is obsolete, use Package/PKG_NAME/description”。</li><li><strong>URL</strong> 表示软件包的下载位置。</li><li><strong>MAINTAIER</strong> 表示维护者，选项。</li><li><strong>DEPENDS</strong> 表示与其他软件的依赖。<strong>运行本软件依赖的其他包</strong>。如果存在多个依赖，则每个依赖需要用空格分开。依赖前使用+号表示默认为显示，即对象没有选中时也会显示，使用@则默认为不显示，即当依赖对象选中后才显示。</li></ul><blockquote><p>在用户空间的应用程序软件包中没有内核驱动模块的AUTOLOAD参数。<strong>如果应用软件需要在boot时自动运行，则需要在/etc/init.d中增加相应的脚本文件。脚本文件需要START参数，说明在boot时的优先级，如果在boot过程启动后再关闭，则需要进一步设置STOP参数。如果STOP参数存在，其值必须大于START。脚本文件需要start()和stop()两个函数，start()是执行程序，stop()是关闭程序。</strong>关闭程序一般需要执行killall命令。由/etc/rc.d/S10boot知道，装载内核驱动模块的优先级为10，需要使用自己设计的内核驱动模块的程序其START的值必须大于10。同样由/etc/rc.d/S40network知道，使用网络通信的程序其START的值必须大于40。</p></blockquote><ul><li><strong>Package/$(PKG_NAME)/conffiles</strong> 本包安装的配置文件，一行一个。如果文件结尾使用/，则表示为目录。用于备份配置文件说明，在sysupgrade命令执行时将会用到。</li><li><strong>Package/$(PKG_NAME)/description</strong> 软件包的详细描述，取代前面提到的DESCRIPTION详细描述。</li><li><strong>Build/Prepare</strong> 编译准备方法，对于网上下载的软件包不需要再描述。对于非网上下载或自行开发的软件包必须说明编译准备方法。一般的准备方法为：</li></ul><pre class="line-numbers language-ruby"><code class="language-ruby">define <span class="token constant">Build</span><span class="token operator">/</span><span class="token constant">Prepare</span>    mkdir <span class="token operator">-</span>p $<span class="token punctuation">(</span><span class="token constant">PKG_BUILD_DIR</span><span class="token punctuation">)</span>    $<span class="token punctuation">(</span><span class="token constant">CP</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token regex">/* $(PKG_BUILD_DIR)/</span>endef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>按OpenWrt的习惯，一般把自己设计的程序全部在src目录下。</p><ul><li><strong>Build/Compile</strong> 编译方法，没有特别说明的可以不予以定义。如果不定义将默认使用编译方法Build/Compile/Default。<br> 自行开发的软件包可以考虑使用下面的定义。</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Build/Compile    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span> \    <span class="token variable">$</span><span class="token punctuation">(</span>TARGET_CONFIGURE_OPTS<span class="token punctuation">)</span>   CFLAGS<span class="token operator">=</span><span class="token string">"$(TARGET_CFLAGS) -I $(LINUX_DIR)/include"</span><span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Package/$(PKG_NAME)/install</strong> 软件包的安装方法，包括一系列拷贝编译好的文件到指定位置。<strong>调用时会带一个参数，就是嵌入式系统的镜像文件系统目录</strong>，因此<strong>$(1)表示嵌入式系统的镜像目录</strong>。一般可以采用下面的方法：</li></ul><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Package/<span class="token variable">$</span><span class="token punctuation">(</span>PKG_NAME<span class="token punctuation">)</span>/install    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/bin    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>PKG_NAME<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/usr/bin/<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>INSTALL_DIR、INSTALL_BIN在$(TOPDIR)/rules.mk文件定义，所以本Makefile必须引入$(TOPDIR)/rules.mk文件。<br> <strong>INSTALL_DIR:=install -d -m0755</strong> 意思是创建所属用户可读写和执行，其他用户可读可执行的目录。<br> <strong>INSTALL_BIN:=install -m0755</strong> 意思是编译好的文件存放到镜像文件目录。<br> 如果用户空间的应用软件在boot时要自动运行，则需要在安装方法说明中增加自动运行的脚本文件安装和配置文件安装方法。<br> 例如：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token keyword">define</span> Package/mountd/install    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DIR<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/sbin/ <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/config/ <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/init.d/    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>PKG_BUILD_DIR<span class="token punctuation">)</span>/mountd <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/sbin/    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_DATA<span class="token punctuation">)</span> ./files/mountd.config <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/config/mountd    <span class="token variable">$</span><span class="token punctuation">(</span>INSTALL_BIN<span class="token punctuation">)</span> ./files/mountd.init <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>/etc/init.d/mountd<span class="token keyword">endef</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装文件放在files子目录下，不要与源代码文件目录src混在一起，以提高可读性。使用清晰的文件扩展名，更方便安装识别文件。</p><ul><li><strong>Package/$(PKG_NAME)/preinst</strong> 软件包安装前处理方法，使用脚本语言，因此定义的第一行需要下面的格式<br> <code>#!/bin/sh</code><br> 调用时带入的参数为嵌入式系统的镜像目录。</li><li><strong>Package/$(PKG_NAME)/postinst</strong> 软件包安装后处理方法，使用脚本语言。</li><li><strong>Package/$(PKG_NAME)/prerm</strong> 软件包删除前处理方法，使用脚本语言。</li><li><strong>Package/$(PKG_NAME)/postrm</strong> 软件包删除后处理方法，使用脚本语言。</li></ul><p><strong>注意：</strong>对于所有在pre/post, install/removal脚本中使用的变量，<strong>都应该使用”$$“代替”$“</strong>。这是告诉make暂时不要解析这个变量，而是把它当成普通字符串以及用”$“代替”$$“</p><h2 id="内核驱动模块包定义"><a href="#内核驱动模块包定义" class="headerlink" title="内核驱动模块包定义"></a>内核驱动模块包定义</h2><p>Linux分为内核空间和用户空间。开发者开发的内核部分可以直接加入Linux的Kernel程序，也可以生成内核模块以便需要时装入内核。OpenWrt一般希望开发者生成内核模块，在Linux启动后自动装载或手工使用insmod命令装载。内核模块使用KernelPackage开头，其他与一般应用软件包基本相同。<br> 在内核驱动模块定义中增加了：</p><ul><li><strong>SUBMENU</strong> 表示子菜单位置，在$(INCLUDE)/kernel.mk对内核模块定义了CATEGORY为kernel modules，所以内核模块在menuconfig中的主菜单为kernel modules，然后有下一级子菜单$(SUBMENU)。在子菜单下可以看到以kmod-$(PKG_NAME)项目。</li><li><strong>DEFAULT</strong> 表示直接编入内核或产生内核模块，y表示直接编入内核，m表示产生内核模块。</li><li><strong>AUTOLOAD</strong> 表示自动装入内核，一般表示方法为：<br> <code>AUTOLOAD:=$(call AutoLoad, $(PRIORITY),$(AUTOLOAD_MODS))</code><br> AutoLoad的第一个参数$(PRIORITY)为优先级，01为最优先，99为最后装载。有关自动装载可以在/etc/modules.d目录下看到，第二个参数$(AUTOLOAD_MODS)模块名，每个模块名以空格符分隔。即可同时装载多个内核模块。<br> 在开发过程最好不要使用自动装载，经过严格调试后再使用，可以减轻调试的工作量。</li></ul><h2 id="使用定义"><a href="#使用定义" class="headerlink" title="使用定义"></a>使用定义</h2><p>完成前面定义后，必须使用eval函数实现各种定义。其格式为：<br> 对于一般应用软件包<br> <code>$(eval $(call Package, $(PKG_NAME)))</code><br> 或对于内核驱动模块<br> <code>$(eval $(call KernelPackage, $(PKG_NAME)))</code><br> 如果一个软件包有多个程序，例如：一个应用程序有自己的内核驱动模块，上面使用PKG_NAME需要灵活变通。eval函数可以设计多个。也可以当成多个软件包处理。</p><h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><blockquote><p><a href="https://www.jianshu.com/p/21c8937ac7ea" target="_blank" rel="noopener">https://www.jianshu.com/p/21c8937ac7ea</a></p><p><a href="https://openwrt.org/zh-cn/doc/devel/packages" target="_blank" rel="noopener">https://openwrt.org/zh-cn/doc/devel/packages</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typoro PicGo MarkDown协同工作</title>
      <link href="/article/32c0b2ae/"/>
      <url>/article/32c0b2ae/</url>
      
        <content type="html"><![CDATA[<h1 id="Tyora简介"><a href="#Tyora简介" class="headerlink" title="Tyora简介"></a>Tyora简介</h1><ul><li><p>官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p></li><li><p>Typora 是一款简单、高效而且非常优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。</p><p>Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。</p><p>Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一。</p></li><li><p>Tyora快捷键</p><ul><li>段落<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200213002205.png" alt></li><li>格式<br><img src="https://cdn.jsdelivr.net/gh/littlekang-code/kangimages/imgs/20200213002455.png" alt></li></ul></li></ul><h1 id="Pandoc文档格式转化"><a href="#Pandoc文档格式转化" class="headerlink" title="Pandoc文档格式转化"></a>Pandoc文档格式转化</h1><ul><li><p>官网 <a href="https://pandoc.org/" target="_blank" rel="noopener">https://pandoc.org/</a></p></li><li><p>简介：</p></li><li><p><em>Pandoc*</em>是一个标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。<br>Typora 的文件导入/导出功能使用 Pandoc 把 Markdown 源码转换成不同的文件格式，所以我们如果想使用文件导入/导出功能，必须先安装 Pandoc。<br>如果不安装 Pandoc，Typora 只支持导出 HTML 和 PDF 格式的文件。<br>如果安装了 Pandoc ：<br>Typora 支持的导入文件格式: .docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub.<br>Typora 支持的导出文件格式 : HTML, PDF, Docx, odt, rtf, Epub, LaTeX, Media Wiki,Image.</p></li><li><p>安装方式：<br>STEP 1. 打开下载页面：<a href="https://github.com/jgm/pandoc/releases/latest" target="_blank" rel="noopener">https://github.com/jgm/pandoc/releases/latest</a><br>STEP 2. 下载最新的安装包：pandoc-版本号.msi<br>STEP 3. 双击后按照提示一步步安装</p></li></ul><h1 id="PicGo图床"><a href="#PicGo图床" class="headerlink" title="PicGo图床"></a>PicGo图床</h1><ul><li><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p></li><li><p>简介：<br>PicGo: 一个用于快速上传图片并获取图片URL链接的工具<br>PicGo 本体支持如下图床：</p><ul><li>微博图床 v1.0 微博图床从 2019 年 4 月开始进行防盗链，不建议继续使用</li><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS v1.5.1 由于官方不再支持V1版本，暂时请使用smms-user插件</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul></li><li><p>特色功能</p><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows和macOS支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：<code>command+shift+p</code>（macOS）| <code>control+shift+p</code>（Windows\Linux)</li><li>支持插件系统，已有插件支持Gitee、青云等第三方图床<ul><li>更多第三方插件以及使用了 PicGo 底层的应用可以在 <a href="https://github.com/PicGo/Awesome-PicGo" target="_blank" rel="noopener">Awesome-PicGo</a> 找到。欢迎贡献！</li></ul></li><li>支持通过发送HTTP请求调用 PicGo 上传（v2.2.0+)</li></ul></li></ul><h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><blockquote><p><a href="https://www.jianshu.com/p/45ff441ac0d6" target="_blank" rel="noopener">Typora：简单高效的 Markdown 编辑器</a><br><a href="https://www.jianshu.com/p/a0bf28d7f2fd" target="_blank" rel="noopener">Typora + PicGo MarkDown完美组合</a><br><a href="https://www.jianshu.com/p/44c8aaa9cda1" target="_blank" rel="noopener">Typora - 不要太棒的Markdown编辑器</a><br><a href="https://www.cnblogs.com/lc1203/p/ac5d44992d9c5f84bf3383d15aff40c2.html" target="_blank" rel="noopener">高效且优雅的笔记记录：为知笔记+Typora+图床</a><br><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Picgo github readme</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高效 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo cmd</title>
      <link href="/article/339e02f9/"/>
      <url>/article/339e02f9/</url>
      
        <content type="html"><![CDATA[<h1 id="新建网站"><a href="#新建网站" class="headerlink" title="新建网站"></a>新建网站</h1><pre><code>hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><pre><code>hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code>hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h1 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h1><pre><code>hexo g</code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h1 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h1><pre><code>hexo s</code></pre><p>默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>hexo d</code></pre><h1 id="清除生成的静态页面"><a href="#清除生成的静态页面" class="headerlink" title="清除生成的静态页面"></a>清除生成的静态页面</h1><pre><code>hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>引用地址：</p><p>从hexo.io说明文档拷贝</p><blockquote><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/article/d4a1185/"/>
      <url>/article/d4a1185/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这是一个测试。<br><img src="https://s2.ax1x.com/2020/02/10/15r7oF.png" alt="15r7oF.png"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world !\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
